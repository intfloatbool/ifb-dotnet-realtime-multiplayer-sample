# IFB Realtime Multiplayer Sample

[**ENGLISH**](./README_EN.md)

Учебно-исследовательский проект по **реализации real-time сетевого взаимодействия**: клиент–серверная архитектура + Unity-клиент с визуализацией синхронизируемых объектов.

Проект создан для **глубокого понимания сетевых архитектур**, очередей сообщений, задержек, интерполяции и обработки состояния в real-time системах (игры, симуляции).   

![](./Resources/demo_gif.gif)


---

## 🎯 Цель проекта

* Разобраться **как на самом деле работает real-time синхронизация**
* Уйти от «магии» готовых сетевых движков
* Реализовать полный путь:

    * сериализация → отправка → приём → обработка → визуализация
* Исследовать задержки, очереди сообщений, тики и интерполяцию на практике

Проект **не является игрой** и не стремится к production-качеству — фокус именно на архитектуре и процессе.

---

## 🧠 Что реализовано

* Сервер и клиенты на **.NET**
* Транспорт: **ENet**
* Сериализация: **MessagePack**
* Клиентская интерполяция состояния
* Очереди входящих сообщений
* Unity-клиент как визуальный consumer сетевого состояния
* Интеграционные тесты сетевого взаимодействия

В Unity:

* каждый подключившийся клиент представлен сферой
* позиции сфер синхронизируются в реальном времени
* движение сглаживается на клиенте

---

## 🧩 Архитектура проекта

```
IRM_Network_Sample
├── IRMShared        # Общие структуры, сообщения, enums, buffer pool
├── IRMServer        # Сервер (relay + логика регистрации клиентов)
├── IRMClient        # Клиентская библиотека
├── IRMClientCLI     # Консольный клиент для тестирования
├── IRMTests         # Интеграционные тесты
└── UnitySample
    └── NetworkPlugin
        └── NetworkTest.unity  # Unity-сцена с визуализацией
```

---

## 📦 Основные модули

### `IRMShared`

Общий слой, используемый сервером и клиентами:

* типы сообщений
* флаги доставки
* буферы и пул памяти
* логирование
* протокол сообщений

Это **контракт**, который гарантирует, что сервер и клиент говорят на одном языке.

---

### `IRMServer`

Серверное приложение:

* приём клиентов
* регистрация пользователей
* ретрансляция сообщений между клиентами
* базовая логика маршрутизации сообщений

Сервер **не занимается визуализацией**, только обработкой сетевого состояния.

---

### `IRMClient`

Клиентская библиотека:

* подключение к серверу
* отправка и приём сообщений
* очередь входящих пакетов
* подготовка данных для consumer’ов (CLI / Unity)

---

### `IRMClientCLI`

Простой CLI-клиент для:

* тестирования сетевого протокола
* отладки логики без Unity
* воспроизводимых сценариев

---

### `IRMTests`

Интеграционные тесты:

* проверка клиент–серверного взаимодействия
* валидация протокола сообщений
* базовая гарантия корректной передачи данных

---

### `UnitySample`

Unity-проект, использующий клиентскую библиотеку:

* визуализация подключённых клиентов
* синхронизация позиций объектов
* клиентская интерполяция движения
* демонстрация real-time обновлений

Unity здесь — **не центр архитектуры**, а лишь визуальный слой.

---

## 🧪 Что можно исследовать на базе проекта

Проект намеренно сделан простым, чтобы на его основе можно было изучать:

* влияние задержек и частоты отправки
* обработку очередей сообщений
* разницу между tick-rate и frame-rate
* client-side interpolation
* jitter и неравномерную доставку пакетов
* разделение ответственности клиента и сервера
* основы authority-моделей

---

## 🚀 Для кого этот проект

* Unity-разработчики, которые хотят понять сети глубже
* Инженеры, изучающие real-time системы
* Те, кто хочет **понять**, а не просто «использовать Photon»
* Учебный и исследовательский проект для портфолио

---

## ⚠️ Важно

* Проект **не претендует на production-ready**
* Нет prediction / reconciliation (умышленно)
* Архитектура сделана читаемой, а не максимально оптимизированной
* Код ориентирован на понимание, а не на минимизацию строк

---
